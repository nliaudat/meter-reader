
# for flashing : press boot button for 2-3 seconds before the serial connection initialize
# After OTA update, the EN (reset) button must be pressed to run firmware

# external_components:
  # - source: github://pr#7639 #https://github.com/esphome/esphome/pull/7639
    # components: [camera, camera_encoder, camera_scaler, esp32_camera, template]
    # refresh: 1h
   
   
   
   #working
external_components:
  # - source: github://pr#9496 #https://github.com/esphome/esphome/pull/9496
    # components: [esp32_camera]
    # refresh: 1h
   
## only if sdcard   
##### sdcard component are not compatible now for esphome 2025.7 : ESP-IDF 5.3.2 introduced changes to SPI/SDMMC drivers

   
    
  # - source:
      # type: git
      # url: https://github.com/n-serrette/esphome_sd_card
      ## ref: refs/pull/26/head  # Specific reference to PR #26
    # components: [sd_mmc_card]


 

# external_components:    
  - source:
      type: local
      path: components 
    components: [meter_reader_tflite] # then load esp-tflite-micro, esp-nn and eventually espressif/esp_jpeg if pixel_format = JPEG
      



############## General configuration

substitutions:

  # board_has_lan: "false"   # if using ethernet in AI-On-The-Edge-Cam_Esp32-S3.yaml
  # network_mode: "wifi" # or "lan" 

  name: s3cam #no special caracters
  friendly_name: "S3 camera"
  id_prefix: "s3_cam" #if you have more than one board, it could be usefull to remane all the "id:prefix_xxxx" with a decicaded prefix
  revision: "1.0"
  
  # camera
  camera_pixel_format: JPEG # (cropping implementation is faster with RGB888 format) | Displays: RGB565, RGB888 | Cameras: YUV422, YUV420, RAW | Efficiency: Grayscale, YUV420, JPEG
  # camera_width: 640
  # camera_height: 480
  camera_resolution: 640x480 #800x600 #640x480 #https://esphome.io/components/esp32_camera.html
  camera_jpeg_quality: 10 # From 10 (best) to 63 (worst).
  camera_max_framerate: 5fps
  camera_idle_framerate: 1fps  # Ensure continuous capture 0.1fps # 10sec
    
  #time
  TZ: "Europe/Zurich" #timezone
  reboot_days_of_week: "MON"
  reboot_hours: "5"
  reboot_minutes: "0"
  reboot_seconds: "0"

  
preferences:
  flash_write_interval: 60min
  

ota:
  - platform: esphome

safe_mode:

# api:
  # reboot_timeout: 30min

#################################################
######### NEW CAMERA COMPONENT ##################
#### https://github.com/esphome/esphome/pull/7639
#################################################

## cannot go to camera.yaml actually. Mean cause PR



# camera_encoder:
    # id: jpeg_encoder
    # quality: BEST # [BEST|HIGH|MED|LOW]
    # subsampling: 444 #[444|420]
    # mcu_count: 256

# camera:
  # - platform: template
    # name: Test Camera
    # camera_encoder_id: jpeg_encoder
    # width: ${camera_width} #512
    # height: ${camera_height} #256
    # image_format: ${camera_pixel_format} #JPEG #RGB888 #     Displays: RGB565, RGB888 | Cameras: YUV422, YUV420, RAW | Efficiency: Grayscale, YUV420, JPEG
    # on_capture_image:
      # - lambda: |-
          # static uint8_t cnt = 0;
          # uint8_t *rgb = image.data;
          # int16_t pixel_cnt = 0;
          # while (context.y < spec.height) {
            # while (context.x < spec.width) {
              # int idx = (context.y * spec.width + context.x) * spec.bytes_per_pixel();
              # rgb[idx + 0] = cnt + context.x;
              # rgb[idx + 1] = cnt + context.y;
              # rgb[idx + 2] = cnt + context.x + context.y;
              # if (context.x < 10 && context.y < 10) {
                # rgb[idx + 0] = 255;
                # rgb[idx + 1] = 0;
                # rgb[idx + 2] = 0;
              # } else if (context.x > 53 && context.y < 10) {
                # rgb[idx + 0] = 0;
                # rgb[idx + 1] = 255;
                # rgb[idx + 2] = 0;
              # } else if (context.x < 10 && context.y > 53){
                # rgb[idx + 0] = 0;
                # rgb[idx + 1] = 0;
                # rgb[idx + 2] = 255;
              # } else if (context.x > 53 && context.y > 53){
                # rgb[idx + 0] = 255;
                # rgb[idx + 1] = 255;
                # rgb[idx + 2] = 0;
              # } else if (context.x >= 27 && context.x < 37 && context.y >= 27 && context.y < 37){
                # rgb[idx + 0] = 0;
                # rgb[idx + 1] = 0;
                # rgb[idx + 2] = 0;
              # }
              # ++context.x;
              # ++pixel_cnt;
            # }
            # context.x = 0;
            # ++context.y;
            # // Incremental image capture. Capture only 16384 pixels in one loop()
            # if (pixel_cnt >= 16384) {
              # context.done = false;
              # return;
            # }
          # }
          # cnt = (cnt + 1) % 128;



# network:
    # enable_ipv6: false
    
    
# web_server:
  # port: 80
  
globals:
  - id: crop_zones
    type: std::string
    restore_value: true
    # initial_value: "\"[]\""
    initial_value: '"[[80, 233, 116, 307], [144, 235, 180, 307]]"'
    # Note: The outer quotes are escaped with single quotes + double quotes ("...")
    #"[[80, 233, 116, 307], [144, 235, 180, 307], [202, 234, 238, 308], [265, 233, 304, 306], [328, 232, 367, 311], [393, 231, 433, 310], [460, 235, 499, 311], [520, 235, 559, 342]]"


text_sensor:
  - platform: template
    name: "Crop Zones"  # Exposed to HA
    id: crop_zones_sensor
    # Update ESPHome when changed from HA
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("crop_zones", "Received crop zones: %s", x.c_str());
            id(crop_zones) = x;  //Store in global var
            id(meter_reader).set_crop_zones(x);

api:
  services:
    - service: set_crop_zones
      variables:
        zones: string
      then:
        - text_sensor.template.publish:
            id: crop_zones_sensor
            state: !lambda 'return zones;'
        - lambda: |-
            id(crop_zones) = zones;  // Update global var
            id(meter_reader).set_crop_zones(zones);
            
            
# sensor:
      # tflite output
    # - platform: template
      # id: tflite_output
      # name: tflite_ouptut
      # accuracy_decimals: 1
      # unit_of_measurement: '%'
  
  
meter_reader_tflite:
  id: meter_reader
  camera_id: ${id_prefix}espcam
  model: "dig-class100-0180-s2-q.tflite"  # Must be in same directory as YAML
  # model_input_width: 20
  # model_input_height: 32
  confidence_threshold: 0.7
  tensor_arena_size: "800KB" # check_tflite_model.py gives : Total Arena Size: 415.08 KB (Approx. RAM needed for inference)
  update_interval: 60s
  # debug_duration: true
  # meter_reader_value_sensor: tflite_output
  # debug: true # can be called with id(meter_reader).test_with_debug_image();
               # 1. Pause normal camera processing
               # 2. Use static debug image
               # 3. Use predefined crop zones
               # 4. Process immediately
               # 5. needs camera_resolution: 640x480
    # on_crop_zones_update:
    # then:
      # - lambda: |-
          # id(meter_reader).set_crop_zones(id(crop_zones).value());


# button:
  # - platform: template
    # name: "Test Debug Image Processing"
    # id: test_debug_image_button
    # icon: "mdi:test-tube"
    # on_press:
      # then:
        # - lambda: |-
            # id(meter_reader).test_with_debug_image();
              # ESP_LOGI("debug", "Debug test image invoked");



packages:
  board: !include board_freenove_esp32-s3-n8r8.yaml
  # board: !include AI-On-The-Edge-Cam_Esp32-S3.yaml
  logger: !include logger.yaml 
  wifi: !include wifi.yaml
  # lan: !include lan.yaml # only for AI-On-The-Edge-Cam_Esp32-S3.yaml + wifi must be disabled
  time: !include time.yaml
  switch_others: !include switch_others.yaml
  sensor_others: !include sensor_others.yaml
  camera_options: !include camera_options.yaml
  esp32_camera: !include esp32_camera.yaml
  camera_webserver: !include camera_webserver.yaml
  globals: !include globals.yaml


