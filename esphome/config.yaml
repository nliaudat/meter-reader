
# for flashing : press boot button for 2-3 seconds before the serial connection initialize
# After OTA update, the EN (reset) button must be pressed to run firmware

# external_components:
  # - source: github://pr#7639 #https://github.com/esphome/esphome/pull/7639
    # components: [camera, camera_encoder, camera_scaler, esp32_camera, template]
    # refresh: 1h
   
   
   
   
external_components:
  - source: github://pr#9496 #https://github.com/esphome/esphome/pull/9496
    components: [esp32_camera]
    refresh: 1h
   
## only if sdcard   
##### sdcard component are not compatible now for esphome 2025.7 : ESP-IDF 5.3.2 introduced changes to SPI/SDMMC drivers

  # - source: github://n-serrette/esphome_sd_card@main  # Explicit branch
    # components: [sd_mmc_card]
    
    
  - source:
      type: git
      url: https://github.com/n-serrette/esphome_sd_card
      ref: refs/pull/26/head  # Specific reference to PR #26
    components: [sd_mmc_card]


  # - source: github://mnark/esphome-components
    # components: [sdmmc]
    # refresh: 1h
    

  # - source: github://espressif/esp-tflite-micro
    # components: [ "tflite_micro" ]
    # refresh: always

  # - source: 
      # type: git
      # url: https://github.com/espressif/esp-tflite-micro
    # components: [tflite_micro]
    # refresh: always

# external_components:    
  - source:
      type: local
      path: components 
    components: [meter_reader_tflite] #, esp-tflite-micro, esp-nn]
      
# esphome:
    # libraries:
      # - espressif/esp-tflite-micro
      # - espressif/esp-nn
      

    
# meter_reader_tflite:
  # model_path: "/sdcard/models/dig-class100-0180-s2-q.tflite"
  # input_width: 96
  # input_height: 96
  # confidence_threshold: 0.7


# micro_wake_word:
  # models:
    # - model: okay_nabu
    
    
# microphone:
  # - platform: i2s_audio
    # id: external_mic
    # adc_type: external
    # i2s_din_pin: GPIO35
    
# i2s_audio:
  # i2s_lrclk_pin: GPIO36
  # i2s_bclk_pin: GPIO37
  
  


############## General configuration

substitutions:

  # board_has_lan: "false"   # if using ethernet in AI-On-The-Edge-Cam_Esp32-S3.yaml
  # network_mode: "wifi" # or "lan" 

  name: s3cam #no special caracters
  friendly_name: "S3 camera"
  id_prefix: "s3_cam" #if you have more than one board, it could be usefull to remane all the "id:prefix_xxxx" with a decicaded prefix
  revision: "1.0"
  
  # camera
  camera_pixel_format: JPEG # (cropping implementation is faster with RGB888 format) | Displays: RGB565, RGB888 | Cameras: YUV422, YUV420, RAW | Efficiency: Grayscale, YUV420, JPEG
  # camera_width: 640
  # camera_height: 480
  camera_resolution: 800x600 #https://esphome.io/components/esp32_camera.html
  camera_jpeg_quality: 10 # From 10 (best) to 63 (worst).
  camera_max_framerate: 5fps
  camera_idle_framerate: 0.1fps # 10sec
    
  #time
  TZ: "Europe/Zurich" #timezone
  reboot_days_of_week: "MON"
  reboot_hours: "5"
  reboot_minutes: "0"
  reboot_seconds: "0"

  
preferences:
  flash_write_interval: 60min
  

ota:
  - platform: esphome

safe_mode:

# api:
  # reboot_timeout: 30min

#################################################
######### NEW CAMERA COMPONENT ##################
#### https://github.com/esphome/esphome/pull/7639
#################################################

## cannot go to camera.yaml actually. Mean cause PR



# camera_encoder:
    # id: jpeg_encoder
    # quality: BEST # [BEST|HIGH|MED|LOW]
    # subsampling: 444 #[444|420]
    # mcu_count: 256

# camera:
  # - platform: template
    # name: Test Camera
    # camera_encoder_id: jpeg_encoder
    # width: ${camera_width} #512
    # height: ${camera_height} #256
    # image_format: ${camera_pixel_format} #JPEG #RGB888 #     Displays: RGB565, RGB888 | Cameras: YUV422, YUV420, RAW | Efficiency: Grayscale, YUV420, JPEG
    # on_capture_image:
      # - lambda: |-
          # static uint8_t cnt = 0;
          # uint8_t *rgb = image.data;
          # int16_t pixel_cnt = 0;
          # while (context.y < spec.height) {
            # while (context.x < spec.width) {
              # int idx = (context.y * spec.width + context.x) * spec.bytes_per_pixel();
              # rgb[idx + 0] = cnt + context.x;
              # rgb[idx + 1] = cnt + context.y;
              # rgb[idx + 2] = cnt + context.x + context.y;
              # if (context.x < 10 && context.y < 10) {
                # rgb[idx + 0] = 255;
                # rgb[idx + 1] = 0;
                # rgb[idx + 2] = 0;
              # } else if (context.x > 53 && context.y < 10) {
                # rgb[idx + 0] = 0;
                # rgb[idx + 1] = 255;
                # rgb[idx + 2] = 0;
              # } else if (context.x < 10 && context.y > 53){
                # rgb[idx + 0] = 0;
                # rgb[idx + 1] = 0;
                # rgb[idx + 2] = 255;
              # } else if (context.x > 53 && context.y > 53){
                # rgb[idx + 0] = 255;
                # rgb[idx + 1] = 255;
                # rgb[idx + 2] = 0;
              # } else if (context.x >= 27 && context.x < 37 && context.y >= 27 && context.y < 37){
                # rgb[idx + 0] = 0;
                # rgb[idx + 1] = 0;
                # rgb[idx + 2] = 0;
              # }
              # ++context.x;
              # ++pixel_cnt;
            # }
            # context.x = 0;
            # ++context.y;
            # // Incremental image capture. Capture only 16384 pixels in one loop()
            # if (pixel_cnt >= 16384) {
              # context.done = false;
              # return;
            # }
          # }
          # cnt = (cnt + 1) % 128;



# network:
    # enable_ipv6: false
    
    
# web_server:
  # port: 80
  
globals:
  - id: crop_zones
    type: std::string
    restore_value: true
    # initial_value: "\"[]\""
    initial_value: '"[[80, 233, 116, 307], [144, 235, 180, 307]]"'
    # Note: The outer quotes are escaped with single quotes + double quotes ("...")
    #"[[80, 233, 116, 307], [144, 235, 180, 307], [202, 234, 238, 308], [265, 233, 304, 306], [328, 232, 367, 311], [393, 231, 433, 310], [460, 235, 499, 311], [520, 235, 559, 342]]"


text_sensor:
  - platform: template
    name: "Crop Zones"  # Exposed to HA
    id: crop_zones_sensor
    # Update ESPHome when changed from HA
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("crop_zones", "Received crop zones: %s", x.c_str());
            id(crop_zones) = x;  //Store in global var
            id(meter_reader).set_crop_zones(x);

api:
  services:
    - service: set_crop_zones
      variables:
        zones: string
      then:
        - text_sensor.template.publish:
            id: crop_zones_sensor
            state: !lambda 'return zones;'
        - lambda: |-
            id(crop_zones) = zones;  // Update global var
            id(meter_reader).set_crop_zones(zones);
  
  
meter_reader_tflite:
  id: meter_reader
  camera_id: ${id_prefix}espcam
  model: "dig-class100-0180-s2-q.tflite"  # Must be in same directory as YAML
  # model_input_width: 20
  # model_input_height: 32
  confidence_threshold: 0.7
  tensor_arena_size: "500KB" # check_tflite_model.py gives : Total Arena Size: 415.08 KB (Approx. RAM needed for inference)
  update_interval: 60s
    # on_crop_zones_update:
    # then:
      # - lambda: |-
          # id(meter_reader).set_crop_zones(id(crop_zones).value());



packages:
  # board: !include board_freenove_esp32-s3-n8r8.yaml
  board: !include AI-On-The-Edge-Cam_Esp32-S3.yaml
  logger: !include logger.yaml
  
# Use Jinja2 conditionals (not working)
# {% if board_has_lan == "true" %}
# <<: !include lan.yaml
# {% else %}
# <<: !include wifi.yaml
# {% endif %}

  # network: !include "{{ network_mode }}.yaml"
    
  wifi: !include wifi.yaml
  # lan: !include lan.yaml # only for AI-On-The-Edge-Cam_Esp32-S3.yaml + wifi must be disabled
  
  time: !include time.yaml
  switch_others: !include switch_others.yaml
  sensor_others: !include sensor_others.yaml
  camera_options: !include camera_options.yaml
  esp32_camera: !include esp32_camera.yaml
  camera_webserver: !include camera_webserver.yaml
  globals: !include globals.yaml


