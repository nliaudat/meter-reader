#pragma once

#include <cstdlib>
#include <vector>
#include <functional>
#include "esphome/core/hal.h"
#include "esphome/core/log.h"
#include "esp_heap_caps.h"

namespace esphome {
namespace memory {

enum MemoryType {
  MEMORY_DEFAULT = 0,     // Let system decide (SPIRAM first, then internal)
  MEMORY_INTERNAL,        // Internal RAM (DRAM)
  MEMORY_SPIRAM,          // External SPI RAM (PSRAM)
  MEMORY_DMA,             // DMA-capable memory
  MEMORY_32BIT,           // 32-bit aligned memory
  MEMORY_8BIT,            // 8-bit accessible memory
  MEMORY_FAST,            // Fast internal memory (IRAM)
  MEMORY_JPEG_ALIGNED     // JPEG-aligned memory (16-byte aligned)
};

/**
 * @brief Platform-aware memory allocation with ESP32-specific memory types
 * @param size Size of memory to allocate
 * @param type Memory type preference
 * @return Pointer to allocated memory, or nullptr on failure
 */
void* platform_malloc(size_t size, MemoryType type = MEMORY_DEFAULT);

/**
 * @brief Platform-aware memory free function
 * @param ptr Pointer to memory to free
 */
void platform_free(void* ptr);

/**
 * @brief Platform-aware memory reallocation
 * @param ptr Pointer to existing memory
 * @param size New size
 * @param type Memory type preference
 * @return Pointer to reallocated memory
 */
void* platform_realloc(void* ptr, size_t size, MemoryType type = MEMORY_DEFAULT);

/**
 * @brief Get available memory of specific type
 * @param type Memory type to check
 * @return Available memory in bytes
 */
size_t get_available_memory(MemoryType type = MEMORY_DEFAULT);

/**
 * @brief Check if specific memory type is available
 * @param type Memory type to check
 * @return True if available
 */
bool has_memory_type(MemoryType type);

/**
 * @brief Get total memory of specific type
 * @param type Memory type to check
 * @return Total memory in bytes
 */
size_t get_total_memory(MemoryType type = MEMORY_DEFAULT);

/**
 * @brief Get largest free block size for specific memory type
 * @param type Memory type to check
 * @return Largest free block size in bytes
 */
size_t get_largest_free_block(MemoryType type = MEMORY_DEFAULT);

/**
 * @brief Memory allocation statistics
 */
struct MemoryStats {
  size_t total;
  size_t free;
  size_t used;
  size_t largest_free_block;
};

/**
 * @brief Get detailed memory statistics
 * @param type Memory type to check
 * @return MemoryStats structure
 */
MemoryStats get_memory_stats(MemoryType type = MEMORY_DEFAULT);

/**
 * @brief Smart pointer with memory type awareness
 */
template<typename T, MemoryType Type = MEMORY_DEFAULT>
class UniquePtr {
 public:
  UniquePtr() : ptr_(nullptr) {}
  
  explicit UniquePtr(size_t count) 
    : ptr_(static_cast<T*>(platform_malloc(count * sizeof(T), Type))) {}
  
  ~UniquePtr() {
    if (ptr_) {
      platform_free(ptr_);
    }
  }
  
  // Disable copy
  UniquePtr(const UniquePtr&) = delete;
  UniquePtr& operator=(const UniquePtr&) = delete;
  
  // Enable move
  UniquePtr(UniquePtr&& other) noexcept : ptr_(other.ptr_) {
    other.ptr_ = nullptr;
  }
  
  UniquePtr& operator=(UniquePtr&& other) noexcept {
    if (this != &other) {
      if (ptr_) {
        platform_free(ptr_);
      }
      ptr_ = other.ptr_;
      other.ptr_ = nullptr;
    }
    return *this;
  }
  
  T* get() const { return ptr_; }
  T* operator->() const { return ptr_; }
  T& operator*() const { return *ptr_; }
  explicit operator bool() const { return ptr_ != nullptr; }
  
  void reset(T* ptr = nullptr) {
    if (ptr_) {
      platform_free(ptr_);
    }
    ptr_ = ptr;
  }
  
 private:
  T* ptr_;
};

/**
 * @brief Memory pool for efficient allocation of fixed-size blocks
 */
class MemoryPool {
 public:
  MemoryPool(size_t block_size, size_t initial_blocks = 10, 
             MemoryType type = MEMORY_DEFAULT);
  ~MemoryPool();
  
  void* allocate();
  void deallocate(void* ptr);
  size_t get_block_size() const { return block_size_; }
  size_t get_allocated_blocks() const { return allocated_blocks_; }
  size_t get_free_blocks() const { return free_blocks_.size(); }
  
 private:
  size_t block_size_;
  MemoryType memory_type_;
  std::vector<void*> free_blocks_;
  std::vector<void*> allocated_blocks_;
};

/**
 * @brief Memory usage tracker for debugging
 */
class MemoryTracker {
 public:
  static MemoryTracker& instance();
  
  void track_allocation(void* ptr, size_t size, const char* tag = "");
  void track_deallocation(void* ptr);
  size_t get_current_usage() const;
  size_t get_peak_usage() const;
  void reset_stats();
  
  void dump_stats() const;
  
 private:
  MemoryTracker() = default;
  
  struct Allocation {
    size_t size;
    const char* tag;
    uint32_t timestamp;
  };
  
  std::unordered_map<void*, Allocation> allocations_;
  size_t current_usage_{0};
  size_t peak_usage_{0};
  mutable std::mutex mutex_;
};

// RAII class for memory tracking
class ScopedMemoryTracker {
 public:
  ScopedMemoryTracker(const char* tag);
  ~ScopedMemoryTracker();
  
 private:
  const char* tag_;
  size_t initial_usage_;
};

}  // namespace memory
}  // namespace esphome