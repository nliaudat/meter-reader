#include "memory_utils.h"
#include "esphome/core/helpers.h"
#include <algorithm>

namespace esphome {
namespace memory {

static const char *const TAG = "memory";

#if defined(ESP_PLATFORM) || defined(USE_ESP_IDF)

void* platform_malloc(size_t size, MemoryType type) {
  if (size == 0) return nullptr;
  
  uint32_t caps = MALLOC_CAP_8BIT;
  const char* type_name = "UNKNOWN";
  
  switch (type) {
    case MEMORY_INTERNAL:
      caps |= MALLOC_CAP_INTERNAL;
      type_name = "INTERNAL";
      break;
    case MEMORY_SPIRAM:
      caps |= MALLOC_CAP_SPIRAM;
      type_name = "SPIRAM";
      break;
    case MEMORY_DMA:
      caps |= MALLOC_CAP_DMA;
      type_name = "DMA";
      break;
    case MEMORY_32BIT:
      caps |= MALLOC_CAP_32BIT;
      type_name = "32BIT";
      break;
    case MEMORY_8BIT:
      caps |= MALLOC_CAP_8BIT;
      type_name = "8BIT";
      break;
    case MEMORY_FAST:
      caps |= MALLOC_CAP_INTERNAL | MALLOC_CAP_IRAM_8BIT;
      type_name = "FAST";
      break;
    case MEMORY_JPEG_ALIGNED:
      caps |= MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT;
      // JPEG requires 16-byte alignment
      void* ptr = heap_caps_aligned_alloc(16, size, caps);
      if (ptr) {
        ESP_LOGD(TAG, "Allocated %zu bytes in JPEG_ALIGNED at %p", size, ptr);
        return ptr;
      }
      // Fall through to default if aligned alloc fails
    case MEMORY_DEFAULT:
    default:
      // Try SPIRAM first, fall back to internal
      void* ptr = heap_caps_malloc(size, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
      if (ptr != nullptr) {
        ESP_LOGD(TAG, "Allocated %zu bytes in SPIRAM at %p", size, ptr);
        return ptr;
      }
      ptr = heap_caps_malloc(size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
      if (ptr != nullptr) {
        ESP_LOGD(TAG, "Allocated %zu bytes in INTERNAL at %p", size, ptr);
        return ptr;
      }
      ESP_LOGE(TAG, "Failed to allocate %zu bytes in DEFAULT", size);
      return nullptr;
  }
  
  void* ptr = heap_caps_malloc(size, caps);
  
  // Fallback logic for specific types
  if (ptr == nullptr) {
    ESP_LOGW(TAG, "Failed to allocate %zu bytes in %s, trying fallback", size, type_name);
    
    switch (type) {
      case MEMORY_SPIRAM:
        ptr = heap_caps_malloc(size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
        if (ptr) {
          ESP_LOGD(TAG, "Fallback to INTERNAL successful");
        }
        break;
      case MEMORY_DMA:
        ptr = heap_caps_malloc(size, MALLOC_CAP_DEFAULT);
        if (ptr) {
          ESP_LOGD(TAG, "Fallback to DEFAULT successful");
        }
        break;
      case MEMORY_FAST:
        ptr = heap_caps_malloc(size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
        if (ptr) {
          ESP_LOGD(TAG, "Fallback to INTERNAL successful");
        }
        break;
      case MEMORY_JPEG_ALIGNED:
        ptr = heap_caps_malloc(size, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
        if (ptr) {
          ESP_LOGD(TAG, "Fallback to SPIRAM successful (not aligned)");
        }
        break;
      default:
        break;
    }
  }
  
  if (ptr) {
    ESP_LOGD(TAG, "Allocated %zu bytes in %s at %p", size, type_name, ptr);
  } else {
    ESP_LOGE(TAG, "Failed to allocate %zu bytes in %s", size, type_name);
  }
  
  return ptr;
}

void platform_free(void* ptr) {
  if (ptr) {
    heap_caps_free(ptr);
  }
}

void* platform_realloc(void* ptr, size_t size, MemoryType type) {
  if (ptr == nullptr) {
    return platform_malloc(size, type);
  }
  
  if (size == 0) {
    platform_free(ptr);
    return nullptr;
  }
  
  // Try to realloc in place first
  void* new_ptr = heap_caps_realloc(ptr, size, MALLOC_CAP_8BIT);
  if (new_ptr != nullptr) {
    return new_ptr;
  }
  
  // Fallback: alloc + copy + free
  void* temp = platform_malloc(size, type);
  if (temp != nullptr) {
    // Get original size from heap info (this is approximate)
    size_t old_size = heap_caps_get_allocated_size(ptr);
    size_t copy_size = std::min(old_size, size);
    memcpy(temp, ptr, copy_size);
    platform_free(ptr);
  }
  return temp;
}

size_t get_available_memory(MemoryType type) {
  multi_heap_info_t info;
  uint32_t caps = MALLOC_CAP_8BIT;
  
  switch (type) {
    case MEMORY_INTERNAL:
      caps |= MALLOC_CAP_INTERNAL;
      break;
    case MEMORY_SPIRAM:
      caps |= MALLOC_CAP_SPIRAM;
      break;
    case MEMORY_DMA:
      caps |= MALLOC_CAP_DMA;
      break;
    case MEMORY_32BIT:
      caps |= MALLOC_CAP_32BIT;
      break;
    case MEMORY_8BIT:
      caps |= MALLOC_CAP_8BIT;
      break;
    case MEMORY_FAST:
      caps |= MALLOC_CAP_IRAM_8BIT;
      break;
    case MEMORY_DEFAULT:
    default:
      caps = MALLOC_CAP_DEFAULT;
      break;
  }
  
  heap_caps_get_info(&info, caps);
  return info.total_free_bytes;
}

bool has_memory_type(MemoryType type) {
  switch (type) {
    case MEMORY_SPIRAM:
      return heap_caps_get_free_size(MALLOC_CAP_SPIRAM) > 0;
    case MEMORY_DMA:
      return heap_caps_get_free_size(MALLOC_CAP_DMA) > 0;
    case MEMORY_FAST:
      return heap_caps_get_free_size(MALLOC_CAP_IRAM_8BIT) > 0;
    default:
      return true;
  }
}

size_t get_total_memory(MemoryType type) {
  uint32_t caps = MALLOC_CAP_8BIT;
  
  switch (type) {
    case MEMORY_INTERNAL:
      caps |= MALLOC_CAP_INTERNAL;
      break;
    case MEMORY_SPIRAM:
      caps |= MALLOC_CAP_SPIRAM;
      break;
    case MEMORY_DMA:
      caps |= MALLOC_CAP_DMA;
      break;
    case MEMORY_32BIT:
      caps |= MALLOC_CAP_32BIT;
      break;
    case MEMORY_8BIT:
      caps |= MALLOC_CAP_8BIT;
      break;
    case MEMORY_FAST:
      caps |= MALLOC_CAP_IRAM_8BIT;
      break;
    case MEMORY_DEFAULT:
    default:
      caps = MALLOC_CAP_DEFAULT;
      break;
  }
  
  return heap_caps_get_total_size(caps);
}

size_t get_largest_free_block(MemoryType type) {
  multi_heap_info_t info;
  uint32_t caps = MALLOC_CAP_8BIT;
  
  switch (type) {
    case MEMORY_INTERNAL:
      caps |= MALLOC_CAP_INTERNAL;
      break;
    case MEMORY_SPIRAM:
      caps |= MALLOC_CAP_SPIRAM;
      break;
    case MEMORY_DMA:
      caps |= MALLOC_CAP_DMA;
      break;
    case MEMORY_32BIT:
      caps |= MALLOC_CAP_32BIT;
      break;
    case MEMORY_8BIT:
      caps |= MALLOC_CAP_8BIT;
      break;
    case MEMORY_FAST:
      caps |= MALLOC_CAP_IRAM_8BIT;
      break;
    case MEMORY_DEFAULT:
    default:
      caps = MALLOC_CAP_DEFAULT;
      break;
  }
  
  heap_caps_get_info(&info, caps);
  return info.largest_free_block;
}

MemoryStats get_memory_stats(MemoryType type) {
  multi_heap_info_t info;
  uint32_t caps = MALLOC_CAP_8BIT;
  
  switch (type) {
    case MEMORY_INTERNAL:
      caps |= MALLOC_CAP_INTERNAL;
      break;
    case MEMORY_SPIRAM:
      caps |= MALLOC_CAP_SPIRAM;
      break;
    case MEMORY_DMA:
      caps |= MALLOC_CAP_DMA;
      break;
    case MEMORY_32BIT:
      caps |= MALLOC_CAP_32BIT;
      break;
    case MEMORY_8BIT:
      caps |= MALLOC_CAP_8BIT;
      break;
    case MEMORY_FAST:
      caps |= MALLOC_CAP_IRAM_8BIT;
      break;
    case MEMORY_DEFAULT:
    default:
      caps = MALLOC_CAP_DEFAULT;
      break;
  }
  
  heap_caps_get_info(&info, caps);
  
  MemoryStats stats;
  stats.total = info.total_allocated_bytes + info.total_free_bytes;
  stats.free = info.total_free_bytes;
  stats.used = info.total_allocated_bytes;
  stats.largest_free_block = info.largest_free_block;
  
  return stats;
}

#elif defined(ARDUINO) && defined(ESP32)

#include "Esp.h"

void* platform_malloc(size_t size, MemoryType type) {
  switch (type) {
    case MEMORY_SPIRAM:
      if (psramFound()) {
        return ps_malloc(size);
      }
      // Fall through to default
    case MEMORY_INTERNAL:
    case MEMORY_DMA:
    case MEMORY_32BIT:
    case MEMORY_8BIT:
    case MEMORY_FAST:
    case MEMORY_DEFAULT:
    default:
      return malloc(size);
  }
}

void platform_free(void* ptr) {
  free(ptr);
}

void* platform_realloc(void* ptr, size_t size, MemoryType type) {
  return realloc(ptr, size);
}

size_t get_available_memory(MemoryType type) {
  switch (type) {
    case MEMORY_SPIRAM:
      return ESP.getFreePsram();
    case MEMORY_INTERNAL:
    case MEMORY_DEFAULT:
    default:
      return ESP.getFreeHeap();
  }
}

bool has_memory_type(MemoryType type) {
  switch (type) {
    case MEMORY_SPIRAM:
      return psramFound();
    default:
      return true;
  }
}

size_t get_total_memory(MemoryType type) {
  switch (type) {
    case MEMORY_SPIRAM:
      return ESP.getPsramSize();
    case MEMORY_INTERNAL:
    case MEMORY_DEFAULT:
    default:
      return ESP.getHeapSize();
  }
}

size_t get_largest_free_block(MemoryType type) {
  // Arduino ESP32 doesn't provide this info easily
  return get_available_memory(type);
}

MemoryStats get_memory_stats(MemoryType type) {
  MemoryStats stats;
  stats.total = get_total_memory(type);
  stats.free = get_available_memory(type);
  stats.used = stats.total - stats.free;
  stats.largest_free_block = get_largest_free_block(type);
  return stats;
}

#else // Generic platforms

void* platform_malloc(size_t size, MemoryType type) {
  return malloc(size);
}

void platform_free(void* ptr) {
  free(ptr);
}

void* platform_realloc(void* ptr, size_t size, MemoryType type) {
  return realloc(ptr, size);
}

size_t get_available_memory(MemoryType type) {
  return 0; // Not available
}

bool has_memory_type(MemoryType type) {
  return true;
}

size_t get_total_memory(MemoryType type) {
  return 0; // Not available
}

size_t get_largest_free_block(MemoryType type) {
  return 0; // Not available
}

MemoryStats get_memory_stats(MemoryType type) {
  return MemoryStats{0, 0, 0, 0};
}

#endif

// MemoryPool implementation
MemoryPool::MemoryPool(size_t block_size, size_t initial_blocks, MemoryType type)
  : block_size_(block_size), memory_type_(type) {
  
  for (size_t i = 0; i < initial_blocks; i++) {
    void* block = platform_malloc(block_size_, memory_type_);
    if (block) {
      free_blocks_.push_back(block);
    }
  }
}

MemoryPool::~MemoryPool() {
  for (void* block : free_blocks_) {
    platform_free(block);
  }
  for (void* block : allocated_blocks_) {
    platform_free(block);
  }
}

void* MemoryPool::allocate() {
  if (!free_blocks_.empty()) {
    void* block = free_blocks_.back();
    free_blocks_.pop_back();
    allocated_blocks_.push_back(block);
    return block;
  }
  
  void* new_block = platform_malloc(block_size_, memory_type_);
  if (new_block) {
    allocated_blocks_.push_back(new_block);
  }
  return new_block;
}

void MemoryPool::deallocate(void* ptr) {
  auto it = std::find(allocated_blocks_.begin(), allocated_blocks_.end(), ptr);
  if (it != allocated_blocks_.end()) {
    allocated_blocks_.erase(it);
    free_blocks_.push_back(ptr);
  }
}

// MemoryTracker implementation
MemoryTracker& MemoryTracker::instance() {
  static MemoryTracker instance;
  return instance;
}

void MemoryTracker::track_allocation(void* ptr, size_t size, const char* tag) {
  std::lock_guard<std::mutex> lock(mutex_);
  allocations_[ptr] = {size, tag, millis()};
  current_usage_ += size;
  peak_usage_ = std::max(peak_usage_, current_usage_);
}

void MemoryTracker::track_deallocation(void* ptr) {
  std::lock_guard<std::mutex> lock(mutex_);
  auto it = allocations_.find(ptr);
  if (it != allocations_.end()) {
    current_usage_ -= it->second.size;
    allocations_.erase(it);
  }
}

size_t MemoryTracker::get_current_usage() const {
  std::lock_guard<std::mutex> lock(mutex_);
  return current_usage_;
}

size_t MemoryTracker::get_peak_usage() const {
  std::lock_guard<std::mutex> lock(mutex_);
  return peak_usage_;
}

void MemoryTracker::reset_stats() {
  std::lock_guard<std::mutex> lock(mutex_);
  current_usage_ = 0;
  peak_usage_ = 0;
  allocations_.clear();
}

void MemoryTracker::dump_stats() const {
  std::lock_guard<std::mutex> lock(mutex_);
  
  ESP_LOGI(TAG, "Memory Tracker Stats:");
  ESP_LOGI(TAG, "  Current Usage: %.2f KB", current_usage_ / 1024.0f);
  ESP_LOGI(TAG, "  Peak Usage: %.2f KB", peak_usage_ / 1024.0f);
  ESP_LOGI(TAG, "  Active Allocations: %zu", allocations_.size());
  
  std::unordered_map<const char*, size_t> usage_by_tag;
  for (const auto& alloc : allocations_) {
    usage_by_tag[alloc.second.tag] += alloc.second.size;
  }
  
  for (const auto& entry : usage_by_tag) {
    ESP_LOGI(TAG, "  %s: %.2f KB", entry.first, entry.second / 1024.0f);
  }
}

// ScopedMemoryTracker implementation
ScopedMemoryTracker::ScopedMemoryTracker(const char* tag) : tag_(tag) {
  initial_usage_ = MemoryTracker::instance().get_current_usage();
}

ScopedMemoryTracker::~ScopedMemoryTracker() {
  size_t final_usage = MemoryTracker::instance().get_current_usage();
  size_t delta = final_usage - initial_usage_;
  
  if (delta > 0) {
    ESP_LOGD(TAG, "Memory usage for %s: +%.2f KB", tag_, delta / 1024.0f);
  }
}

}  // namespace memory
}  // namespace esphome